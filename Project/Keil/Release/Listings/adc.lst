C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 15:20:23 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\Ob
                    -jects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          
   4          // å­˜æ”¾æ¸©åº¦çŠ¶æ€çš„å˜é‡
   5          volatile u8 temp_status = TEMP_NORMAL;
   6          
   7          // volatile u16 adc_val_from_engine; // å­˜æ”¾ ä»å‘åŠ¨æœºä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
   8          // volatile u16 adc_val_from_knob;   // å­˜æ”¾ ä»æ—‹é’®ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
   9          // volatile u16 adc_val_from_temp;   // å­˜æ”¾ ä»çƒ­æ•ç”µé˜»ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  10          // volatile u16 adc_val_from_fan;    // å­˜æ”¾ æ£€æµ‹é£æ‰‡ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  11          
  12          volatile u16 adc_val_from_engine = U16_MAX_VAL; // å­˜æ”¾ ä»å‘åŠ¨æœºä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  13          volatile u16 adc_val_from_knob = U16_MAX_VAL;   // å­˜æ”¾ ä»æ—‹é’®ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  14          volatile u16 adc_val_from_temp = U16_MAX_VAL;   // å­˜æ”¾ ä»çƒ­æ•ç”µé˜»ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  15          volatile u16 adc_val_from_fan = U16_MAX_VAL;    // å­˜æ”¾ æ£€æµ‹é£æ‰‡ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  16          
  17          volatile bit flag_tim_scan_fan_is_err = 0;      // æ ‡å¿—ä½ï¼Œç”±å®šæ—¶å™¨æ‰«æå¹¶ç´¯è®¡æ—¶é—´ï¼Œè¡¨ç¤ºå
             -½“å‰é£æ‰‡æ˜¯å¦å¼‚å¸¸
  18          volatile u8 cur_fan_status = FAN_STATUS_NORMAL; // å½“å‰é£æ‰‡çŠ¶æ€
  19          
  20          volatile u8 cur_adc_status = ADC_STATUS_NONE; // çŠ¶æ€æœºï¼Œè¡¨ç¤ºå½“å‰adcçš„çŠ¶æ€
  21          
  22          // adcç›¸å…³çš„å¼•è„šé…ç½®
  23          void adc_pin_config(void)
  24          {
  25   1          // P30--8è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  26   1          P3_MD0 |= GPIO_P30_MODE_SEL(0x3);
  27   1      
  28   1          // P27--9è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  29   1          P2_MD1 |= GPIO_P27_MODE_SEL(0x3);
  30   1      
  31   1          // P31--7è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  32   1          P3_PU &= ~(0x01 << 1); // å…³é—­ä¸Šæ‹‰
  33   1          P3_PD &= ~(0x01 << 1); // å…³é—­ä¸‹æ‹‰
  34   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x3);
  35   1      
  36   1          // P13 -- èŠ¯ç‰‡çš„1è„šï¼Œé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  37   1          P1_PU &= ~(0x01 << 3);             // å…³é—­ä¸Šæ‹‰
  38   1          P1_PD &= ~(0x01 << 3);             // å…³é—­ä¸‹æ‹‰
  39   1          P1_MD0 |= GPIO_P13_MODE_SEL(0x03); // æ¨¡æ‹ŸIOå·¥ä½œæ¨¡å¼
  40   1      }
  41          
  42          void adc_config(void)
  43          {
  44   1          __EnableIRQ(ADC_IRQn);    // ä½¿èƒ½ADCä¸­æ–­
  45   1          IE_EA = 1;                // ä½¿èƒ½æ€»ä¸­æ–­
  46   1          ADC_CFG1 |= (0x0F << 3) | // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
  47   1                      (0x01 << 0);  // ADC0 é€šé“ä¸­æ–­ä½¿èƒ½
  48   1          delay_ms(1);              // ç­‰å¾…adcç¨³å®š
  49   1      }
  50          
  51          void adc_channel_sel(u8 adc_sel_pin)
  52          {
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 15:20:23 PAGE 2   

  53   1      
  54   1          __EnableIRQ(ADC_IRQn); // ä½¿èƒ½ADCä¸­æ–­
  55   1          IE_EA = 1;             // ä½¿èƒ½æ€»ä¸­æ–­
  56   1      
  57   1          switch (adc_sel_pin)
  58   1          {
  59   2          case ADC_SEL_PIN_ENGINE:
  60   2          {
  61   3              // ADCé…ç½®
  62   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
  63   3              ADC_ACON1 |= ADC_VREF_SEL(0x5) |                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ
             -‰‹å†Œè¯´æœªæ ¡å‡†)
  64   3                           ADC_TEN_SEL(0x3);                           /* å…³é—­æµ‹è¯•ä¿¡å· */
  65   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                            // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  66   3                          ADC_BIAS_EN(0x1) |                           // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  67   3                          ADC_BIAS_SEL(0x1);                           // åç½®ç”µæµï¼š1x
  68   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x17) |                       // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P2
             -7ï¼‰
  69   3                         ADC_EXT_SEL(0x0);                             // é€‰æ‹©å¤–éƒ¨é€šé“
  70   3          }
  71   2          break;
  72   2      
  73   2          case ADC_SEL_PIN_KNOB:
  74   2          {
  75   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ã€æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  76   3              ADC_ACON1 |= ADC_VREF_SEL(0x6) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA
  77   3                           ADC_TEN_SEL(0x3);     // å…³é—­æµ‹è¯•ä¿¡å·
  78   3              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  79   3                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  80   3                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  81   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x19) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
  82   3                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  83   3          }
  84   2          break;
  85   2      
  86   2          case ADC_SEL_PIN_TEMP:
  87   2          {
  88   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå
             -‹
  89   3              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå
             -‹VCCA
  90   3                           ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
  91   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä½¿è
             -ƒ½ä¿¡å·
  92   3                          ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæµè
             -ƒ½ä½¿ä¿¡å·
  93   3                          ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
  94   3      
  95   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
  96   3                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  97   3          }
  98   2          break;
  99   2              // ===============================================================================================
             -==
 100   2          case ADC_SEL_PIN_FAN:
 101   2          {
 102   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç
             -”µå‹ï¼Œä¸é€‰æ‹©å¤–éƒ¨å‚è€ƒï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
 103   3              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                            // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
 104   3                           ADC_TEN_SEL(0x3);                                              // å…³é—­æµ‹è¯•ä¿¡å·
 105   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                                               // æ‰“å¼€ADCä¸­çš„CMPä
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 15:20:23 PAGE 3   

             -½¿èƒ½ä¿¡å·
 106   3                          ADC_BIAS_EN(0x1) |                                              // æ‰“å¼€ADCåç½®ç”µæ
             -µèƒ½ä½¿ä¿¡å·
 107   3                          ADC_BIAS_SEL(0x1);                                              // åç½®ç”µæµï¼š1x
 108   3      
 109   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x0B) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x0B--P13ï¼‰
 110   3                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 111   3          }
 112   2          break;
 113   2              // ===============================================================================================
             -==
 114   2          default:
 115   2              break;
 116   2          }
 117   1      
 118   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0
 119   1                      ADC_EN(0x1);        // ä½¿èƒ½adc
 120   1      }
 121          
 122          // ä»å¼•è„šä¸Šé‡‡é›†æ»¤æ³¢åçš„ç”µå‹å€¼,å‡½æ•°å†…éƒ¨ä¼šå°†é‡‡é›†åˆ°çš„adè½¬æ¢æˆå¯¹åº”çš„ç”µå‹å€¼
 123          u32 get_voltage_from_pin(void)
 124          {
 125   1          return (u32)adc_val_from_temp * 12 / 10;
 126   1      }
 127          
 128          // æ¸©åº¦æ£€æµ‹åŠŸèƒ½
 129          void temperature_scan(void)
 130          {
 131   1          volatile u32 voltage = 0; // å­˜æ”¾adcé‡‡é›†åˆ°çš„ç”µå‹ï¼Œå•ä½ï¼šmV
 132   1      
 133   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå›
             - ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 134   1          if (TEMP_75_5_MIN == temp_status)
 135   1          {
 136   2              return;
 137   2          }
 138   1      
 139   1          {
 140   2              // è°ƒç”¨è¯¥å‡½æ•°ä¸€å®šæ¬¡æ•°ä¹‹åï¼Œæ‰è¿›è¡Œæ¸©åº¦æ£€æµ‹ï¼Œç¼©çŸ­ä¸»å¾ªç¯çš„æ‰§è¡Œå‘¨æœŸ
 141   2              static volatile u8 cnt = 0;
 142   2              cnt++;
 143   2              if (cnt < 100)
 144   2              {
 145   3                  return;
 146   3              }
 147   2      
 148   2              cnt = 0;
 149   2          }
 150   1      
 151   1          voltage = get_voltage_from_pin(); // å¾—åˆ°çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 152   1          if (voltage >= (u32)U16_MAX_VAL * 12 / 10)
 153   1          {
 154   2              // æ²¡æœ‰é‡‡é›†åˆ°adå€¼ï¼Œadå€¼è¿˜æ˜¯åˆå§‹çš„U16_MAX_VALï¼Œä¸å¤„ç†ï¼Œå‡½æ•°ç›´æ¥è¿”å›
 155   2              return;
 156   2          }
 157   1      
 158   1      #if USE_MY_DEBUG
                  // printf("PIN-8 voltage: %lu mV\n", voltage);
              #endif // USE_MY_DEBUG
 161   1      
 162   1          // å¦‚æœä¹‹å‰çš„æ¸©åº¦ä¸ºæ­£å¸¸ï¼Œæ£€æµ‹æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦ï¼ˆÂ±5æ‘„æ°åº¦ï¼‰
 163   1          // if (TEMP_NORMAL == temp_status && voltage < VOLTAGE_TEMP_75)
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 15:20:23 PAGE 4   

 164   1          if (TEMP_NORMAL == temp_status)
 165   1          {
 166   2              // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å
             -€¼ï¼‰
 167   2              static volatile u8 cnt = 0;
 168   2              if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°
             -äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 169   2              {
 170   3                  cnt++;
 171   3              }
 172   2              else
 173   2              {
 174   3                  cnt = 0;
 175   3              }
 176   2      
 177   2              if (cnt >= 10)
 178   2              {
 179   3                  cnt = 0;
 180   3                  // æµ‹è¯•çš„æ—¶å€™ï¼Œå¦‚æœå¼•è„šæ‚¬ç©ºï¼Œå¯èƒ½ä¼šæ‰§è¡Œä¸åˆ°è¿™é‡Œï¼š
 181   3                  temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦   USER_TO_DO  åœ¨æµ‹è¯•æ—¶ä¼š
             -å±è”½æ‰ï¼Œéœ€è¦æ£€æŸ¥ä¸€ä¸‹
 182   3              }
 183   2              else
 184   2              {
 185   3                  temp_status = TEMP_NORMAL;
 186   3              }
 187   2      
 188   2              return; // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
 189   2          }
 190   1          else if (TEMP_75 == temp_status)
 191   1          {
 192   2              // å¦‚æœä¹‹å‰çš„æ¸©åº¦è¶…è¿‡75æ‘„æ°åº¦
 193   2              static bit tmr1_is_open = 0;
 194   2      
 195   2              if (0 == tmr1_is_open)
 196   2              {
 197   3                  tmr1_is_open = 1;
 198   3                  tmr1_cnt = 0;
 199   3                  tmr1_enable(); // æ‰“å¼€å®šæ—¶å™¨ï¼Œå¼€å§‹è®°å½•æ˜¯å¦å¤§äº75æ‘„æ°åº¦ä¸”è¶…è¿‡ä¸€å®šæ—¶é—´
 200   3              }
 201   2      
 202   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†5minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 203   2              if (tmr1_cnt >= (u32)TMR1_CNT_5_MINUTES)
 204   2              {
 205   3                  static volatile u8 cnt = 0;
 206   3      
 207   3                  if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è
             -¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 208   3                  {
 209   4                      cnt++;
 210   4                  }
 211   3                  else
 212   3                  {
 213   4                      cnt = 0;
 214   4                  }
 215   3      
 216   3                  if (cnt >= 10)
 217   3                  {
 218   4                      cnt = 0;
 219   4                      temp_status = TEMP_75_5_MIN; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5min
 220   4                      tmr1_disable();              // å…³é—­å®šæ—¶å™¨
 221   4                      tmr1_cnt = 0;                // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 15:20:23 PAGE 5   

 222   4                      tmr1_is_open = 0;
 223   4                  }
 224   3                  else
 225   3                  {
 226   4                      temp_status = TEMP_75;
 227   4                  }
 228   3      
 229   3                  return;
 230   3              }
 231   2          }
 232   1      }
 233          
 234          // æ ¹æ®æ¸©åº¦ï¼ˆç”µå‹å€¼æ‰«æï¼‰æˆ–9è„šçš„çŠ¶æ€æ¥è®¾å®šå ç©ºæ¯”
 235          void set_duty(void)
 236          {
 237   1          // å¦‚æœæ¸©åº¦æ­£å¸¸ï¼Œæ ¹æ®9è„šçš„çŠ¶æ€æ¥è°ƒèŠ‚PWMå ç©ºæ¯”
 238   1          if (TEMP_NORMAL == temp_status)
 239   1          {
 240   2              if (flag_is_time_to_check_engine)
 241   2              {
 242   3                  flag_is_time_to_check_engine = 0;
 243   3                  according_pin9_to_adjust_pwm();
 244   3              }
 245   2          }
 246   1          else if (TEMP_75 == temp_status)
 247   1          {
 248   2              limited_pwm_duty_due_to_temp = PWM_DUTY_50_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -50%
 249   2          }
 250   1          else if (TEMP_75_5_MIN == temp_status)
 251   1          {
 252   2              limited_pwm_duty_due_to_temp = PWM_DUTY_25_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -25%
 253   2          }
 254   1      }
 255          
 256          void fan_scan(void)
 257          {
 258   1          u16 adc_val = adc_val_from_fan; // adc_val_from_fan ç”±adcä¸­æ–­è§¦å‘
 259   1          if (adc_val == U16_MAX_VAL)
 260   1          {
 261   2              // æ²¡æœ‰é‡‡é›†åˆ°adå€¼ï¼Œadå€¼è¿˜æ˜¯åˆå§‹çš„U16_MAX_VALï¼Œä¸å¤„ç†ï¼Œå‡½æ•°ç›´æ¥è¿”å›
 262   2              return;
 263   2          }
 264   1      
 265   1          /*
 266   1              1è„šç”µå‹ä½äº4.3Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º25%å ç©ºæ¯”ï¼Œ
 267   1              1è„šç”µå‹é«˜äº4.5Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º100%å ç©ºæ¯”
 268   1          */
 269   1          if (FAN_STATUS_NORMAL == cur_fan_status)
 270   1          {
 271   2              if (adc_val <= ADC_VAL_WHEN_FAN_ERR)
 272   2              {
 273   3                  flag_tim_scan_fan_is_err = 1; // è¡¨ç¤ºé£æ‰‡å¼‚å¸¸ï¼Œè®©å®šæ—¶å™¨ç´¯è®¡æ—¶é—´
 274   3              }
 275   2              else
 276   2              {
 277   3                  // é£æ‰‡æ­£å¸¸æ—¶ï¼Œåªè¦æœ‰ä¸€æ¬¡adå€¼ä¸æ»¡è¶³å¼‚å¸¸çš„æ¡ä»¶ï¼Œä¾¿è®¤ä¸ºå®ƒæ˜¯æ­£å¸¸å·¥ä½
             -œ
 278   3                  flag_tim_scan_fan_is_err = 0;
 279   3              }
 280   2      
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 15:20:23 PAGE 6   

 281   2              // é£æ‰‡æ­£å¸¸å·¥ä½œï¼Œpwmæ­£å¸¸è¾“å‡º
 282   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_100_PERCENT;
 283   2          }
 284   1          else // FAN_STATUS_ERROR == cur_fan_status
 285   1          {
 286   2              // é£æ‰‡å¼‚å¸¸æ—¶ï¼Œæ£€æµ‹åˆ°çš„adå€¼è¦ä¸ã€é£æ‰‡å¼‚å¸¸æ—¶å¯¹åº”çš„adå€¼ã€‘ç›¸éš”ä¸€ä¸ªæ­»åŒºï
             -¼Œæ‰è®¤ä¸ºé£æ‰‡æ¢å¤æ­£å¸¸
 287   2              if (adc_val >= ADC_VAL_WHEN_FAN_NORMAL)
 288   2              {
 289   3                  flag_tim_scan_fan_is_err = 0; // è¡¨ç¤ºé£æ‰‡æ­£å¸¸
 290   3              }
 291   2      
 292   2              // é£æ‰‡å·¥ä½œå¼‚å¸¸ï¼Œé™åˆ¶pwmè¾“å‡ºï¼Œå ç©ºæ¯”ä¸è¶…è¿‡25%
 293   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_25_PERCENT;
 294   2          }
 295   1      }
 296          
 297          void ADC_IRQHandler(void) interrupt ADC_IRQn
 298          {
 299   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 300   1          __IRQnIPnPush(ADC_IRQn);
 301   1      
 302   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 303   1          if (ADC_STA & ADC_CHAN0_DONE(0x01))
 304   1          {
 305   2              volatile u16 adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // å…ˆæ¥æ”¶adå€¼
 306   2              ADC_STA |= ADC_CHAN0_DONE(0x01);                              // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 307   2      
 308   2              if (ADC_STATUS_SEL_ENGINE == cur_adc_status)
 309   2              {
 310   3                  // æ›´æ–°å‘åŠ¨æœºæ£€æµ‹ä¸€ç«¯çš„adå€¼
 311   3      
 312   3                  static u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 313   3                  static volatile u32 g_tmpbuff = 0;
 314   3                  static volatile u16 g_adcmax = 0;
 315   3                  static volatile u16 g_adcmin = 0xFFFF;
 316   3      
 317   3                  if (i < 20)
 318   3                  {
 319   4                      i++;
 320   4      
 321   4                      if (i >= 2) // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·å€¼
 322   4                      {
 323   5                          if (adc_val > g_adcmax)
 324   5                              g_adcmax = adc_val; // æœ€å¤§
 325   5                          if (adc_val < g_adcmin)
 326   5                              g_adcmin = adc_val; // æœ€å°
 327   5                          g_tmpbuff += adc_val;
 328   5                      }
 329   4      
 330   4                      if (i < 20)
 331   4                          ADC_CFG0 |= 0x01 << 0; // å¼€å¯adc0è½¬æ¢
 332   4                  }
 333   3      
 334   3                  if (i >= 20)
 335   3                  {
 336   4                      adc_val_from_engine = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
 337   4                      cur_adc_status = ADC_STATUS_SEL_ENGINE_DONE;
 338   4      
 339   4                      // é‡æ–°åˆå§‹åŒ–ä½¿ç”¨åˆ°çš„å˜é‡ï¼š
 340   4                      i = 0;
 341   4                      g_adcmax = 0;
C51 COMPILER V9.60.7.0   ADC                                                               02/05/2026 15:20:23 PAGE 7   

 342   4                      g_adcmin = 0xFFFF;
 343   4                      g_tmpbuff = 0;
 344   4                      // printf("1 engine scan done\n");
 345   4                  }
 346   3              }
 347   2              else if (ADC_STATUS_SEL_KNOB == cur_adc_status)
 348   2              {
 349   3                  // æ›´æ–°æ—‹é’®æ£€æµ‹ä¸€ç«¯çš„adå€¼
 350   3                  adc_val_from_knob = adc_val;
 351   3                  // printf("2 knob scan done\n");
 352   3              }
 353   2              else if (ADC_STATUS_SEL_GET_TEMP == cur_adc_status)
 354   2              {
 355   3                  // æ›´æ–°çƒ­æ•ç”µé˜»æ£€æµ‹ä¸€ç«¯çš„adå€¼
 356   3                  adc_val_from_temp = adc_val;
 357   3                  // printf("3 temp scan done\n");
 358   3              }
 359   2              else if (ADC_STATUS_SEL_FAN_DETECT == cur_adc_status)
 360   2              {
 361   3                  // æ›´æ–°é£æ‰‡æ£€æµ‹ä¸€ç«¯çš„adå€¼
 362   3                  adc_val_from_fan = adc_val;
 363   3                  // printf("4 fan scan done\n");
 364   3              }
 365   2          }
 366   1      
 367   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 368   1          __IRQnIPnPop(ADC_IRQn);
 369   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    863    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     23       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
