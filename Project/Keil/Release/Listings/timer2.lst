C51 COMPILER V9.60.7.0   TIMER2                                                            02/05/2026 15:20:24 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIMER2
OBJECT MODULE PLACED IN .\Release\Objects\timer2.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\timer2.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCD
                    -IR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\timer2.lst) OBJECT(.\Rele
                    -ase\Objects\timer2.obj)

line level    source

   1          #include "timer2.h"
   2          #include "power_on.h"
   3          #define TIMER2_PEROID_VAL (SYSCLK / 128 / 10000 - 1) // å‘¨æœŸå€¼=ç³»ç»Ÿæ—¶é’Ÿ/åˆ†é¢‘/é¢‘çŽ‡ - 1
   4          
   5          static volatile u16 pwm_duty_add_cnt; // ç”¨äºŽæŽ§åˆ¶pwmå¢žåŠ çš„æ—¶é—´è®¡æ•°
   6          static volatile u16 pwm_duty_sub_cnt; // ç”¨äºŽæŽ§åˆ¶pwmé€’å‡çš„æ—¶é—´è®¡æ•°
   7          
   8          volatile bit flag_is_pwm_add_time_comes = 0; // æ ‡å¿—ä½ï¼Œpwmå ç©ºæ¯”é€’å¢žæ—¶é—´åˆ°æ¥
   9          volatile bit flag_is_pwm_sub_time_comes = 0; // æ ‡å¿—ä½ï¼Œpwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
  10          
  11          static volatile u16 pwm_duty_change_cnt = 0; // ç”¨äºŽæŽ§åˆ¶pwmå˜åŒ–çš„æ—¶é—´è®¡æ•°ï¼ˆç”¨åœ¨æ—‹é’®è°ƒèŠ‚ç
             -š„PWMå ç©ºæ¯”ä¸­ï¼‰
  12          
  13          void timer2_config(void)
  14          {
  15   1          __EnableIRQ(TMR2_IRQn); // ä½¿èƒ½timer2ä¸­æ–­
  16   1          IE_EA = 1;              // ä½¿èƒ½æ€»ä¸­æ–­
  17   1      
  18   1          // è®¾ç½®timer2çš„è®¡æ•°åŠŸèƒ½ï¼Œé…ç½®ä¸€ä¸ªé¢‘çŽ‡ä¸º 10 kHzçš„ä¸­æ–­
  19   1          TMR_ALLCON = TMR2_CNT_CLR(0x1);                               // æ¸…é™¤è®¡æ•°å€¼
  20   1          TMR2_PRH = TMR_PERIOD_VAL_H((TIMER2_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  21   1          TMR2_PRL = TMR_PERIOD_VAL_L((TIMER2_PEROID_VAL >> 0) & 0xFF);
  22   1          TMR2_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // è®¡æ•°ç­‰äºŽå‘¨æœŸæ—¶å
             -…è®¸å‘ç”Ÿä¸­æ–­
  23   1          TMR2_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // é€‰æ‹©ç³»ç»Ÿæ—¶é’Ÿï¼Œ1
             -28åˆ†é¢‘ï¼Œè®¡æ•°æ¨¡å¼
  24   1      }
  25          
  26          // å®šæ—¶å™¨ ä¸­æ–­æœåŠ¡å‡½æ•°
  27          void TIMR2_IRQHandler(void) interrupt TMR2_IRQn
  28          {
  29   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
  30   1          __IRQnIPnPush(TMR2_IRQn);
  31   1      
  32   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
  33   1      
  34   1          // å‘¨æœŸä¸­æ–­
  35   1          if (TMR2_CONH & TMR_PRD_PND(0x1)) // çº¦100usè§¦å‘ä¸€æ¬¡ä¸­æ–­
  36   1          {
  37   2              TMR2_CONH |= TMR_PRD_PND(0x1); // æ¸…é™¤pending
  38   2      
  39   2              // tmr2_cnt++;
  40   2              // P13 = ~P13; // æµ‹è¯•ä¸­æ–­è§¦å‘å‘¨æœŸ
  41   2      
  42   2              pwm_duty_add_cnt++;
  43   2              pwm_duty_sub_cnt++;
  44   2              pwm_duty_change_cnt++;
  45   2      
  46   2              if (pwm_duty_sub_cnt >= 13) // 1300usï¼Œ1.3ms
  47   2              // if (pwm_duty_sub_cnt >= 50)
  48   2              {
  49   3                  pwm_duty_sub_cnt = 0;
  50   3                  flag_is_pwm_sub_time_comes = 1;
C51 COMPILER V9.60.7.0   TIMER2                                                            02/05/2026 15:20:24 PAGE 2   

  51   3              }
  52   2      
  53   2              // if (pwm_duty_add_cnt >= 133) // 13300us, 13.3ms
  54   2              if (pwm_duty_add_cnt >= 13) //
  55   2              {
  56   3                  pwm_duty_add_cnt = 0;
  57   3                  flag_is_pwm_add_time_comes = 1;
  58   3              }
  59   2      
  60   2      #if 1 // rfä¿¡å·æŽ¥æ”¶ ï¼ˆ100usè°ƒç”¨ä¸€æ¬¡ï¼‰
  61   2              {
  62   3                  static volatile u8 rf_bit_cnt;            // RFä¿¡å·æŽ¥æ”¶çš„æ•°æ®ä½è®¡æ•°å€¼
  63   3                  static volatile u32 __rf_data;            // å®šæ—¶å™¨ä¸­æ–­ä½¿ç”¨çš„æŽ¥æ”¶ç¼“å†²åŒºï¼Œé¿å…ç
             -›´æŽ¥è¦†ç›–å…¨å±€çš„æ•°æ®æŽ¥æ”¶ç¼“å†²åŒº
  64   3                  static volatile u8 flag_is_enable_recv;   // æ˜¯å¦ä½¿èƒ½æŽ¥æ”¶çš„æ ‡å¿—ä½ï¼Œè¦æŽ¥æ”¶åˆ° 5ms
             -+ çš„ä½Žç”µå¹³æ‰å¼€å§‹æŽ¥æ”¶
  65   3                  static volatile u8 __flag_is_recved_data; // è¡¨ç¤ºä¸­æ–­æœåŠ¡å‡½æ•°æŽ¥æ”¶åˆ°äº†rfæ•°æ®
  66   3      
  67   3                  static volatile u8 low_level_cnt;  // RFä¿¡å·ä½Žç”µå¹³è®¡æ•°å€¼
  68   3                  static volatile u8 high_level_cnt; // RFä¿¡å·é«˜ç”µå¹³è®¡æ•°å€¼
  69   3      
  70   3                  // åœ¨å®šæ—¶å™¨ ä¸­æ‰«æç«¯å£ç”µå¹³
  71   3                  if (0 == RFIN_PIN)
  72   3                  {
  73   4                      // å¦‚æžœRFæŽ¥æ”¶å¼•è„šä¸ºä½Žç”µå¹³ï¼Œè®°å½•ä½Žç”µå¹³çš„æŒç»­æ—¶é—´
  74   4                      low_level_cnt++;
  75   4      
  76   4                      /*
  77   4                          ä¸‹é¢çš„åˆ¤æ–­æ¡ä»¶æ˜¯é¿å…éƒ¨åˆ†é¥æŽ§å™¨æˆ–æŽ¥æ”¶æ¨¡å—åªå‘é€24ä½æ•°æ®ï¼Œæœ€
             -åŽä¸æ‹‰é«˜ç”µå¹³çš„æƒ…å†µ
  78   4                      */
  79   4                      if (low_level_cnt >= 30 && rf_bit_cnt == 23) // å¦‚æžœä½Žç”µå¹³å¤§äºŽ3000usï¼Œå¹¶ä¸”å·²ç»
             -æŽ¥æ”¶äº†23ä½æ•°æ®
  80   4                      {
  81   5                          if (high_level_cnt >= 6 && high_level_cnt < 20)
  82   5                          {
  83   6                              __rf_data |= 0x01;
  84   6                          }
  85   5                          else if (high_level_cnt >= 1 && high_level_cnt < 6)
  86   5                          {
  87   6                          }
  88   5      
  89   5                          __flag_is_recved_data = 1; // æŽ¥æ”¶å®Œæˆæ ‡å¿—ä½ç½®ä¸€
  90   5                          flag_is_enable_recv = 0;
  91   5                      }
  92   4                  }
  93   3                  else
  94   3                  {
  95   4                      if (low_level_cnt > 0)
  96   4                      {
  97   5                          // å¦‚æžœä¹‹å‰æŽ¥æ”¶åˆ°äº†ä½Žç”µå¹³ä¿¡å·ï¼ŒçŽ°åœ¨é‡åˆ°äº†é«˜ç”µå¹³ï¼Œåˆ¤æ–­æ˜¯å¦æŽ
             -¥æ”¶å®Œæˆäº†ä¸€ä½æ•°æ®
  98   5                          if (low_level_cnt > 50)
  99   5                          {
 100   6                              // å¦‚æžœä½Žç”µå¹³æŒç»­æ—¶é—´å¤§äºŽ50 * 100usï¼ˆ5msï¼‰ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡å†è¯»å–
             -æœ‰æ•ˆä¿¡å·
 101   6                              __rf_data = 0;  // æ¸…é™¤æŽ¥æ”¶çš„æ•°æ®å¸§
 102   6                              rf_bit_cnt = 0; // æ¸…é™¤ç”¨æ¥è®°å½•æŽ¥æ”¶çš„æ•°æ®ä½æ•°
 103   6      
 104   6                              flag_is_enable_recv = 1;
 105   6                          }
 106   5                          else if (flag_is_enable_recv &&
C51 COMPILER V9.60.7.0   TIMER2                                                            02/05/2026 15:20:24 PAGE 3   

 107   5                                   low_level_cnt >= 2 && low_level_cnt < 7 &&
 108   5                                   high_level_cnt >= 6 && high_level_cnt < 20)
 109   5                          {
 110   6                              // å¦‚æžœä½Žç”µå¹³æŒç»­æ—¶é—´åœ¨360uså·¦å³ï¼Œé«˜ç”µå¹³æŒç»­æ—¶é—´åœ¨760uså·¦å³
             -ï¼Œè¯´æ˜ŽæŽ¥æ”¶åˆ°äº†1
 111   6                              __rf_data |= 0x01;
 112   6                              rf_bit_cnt++;
 113   6                              if (rf_bit_cnt != 24)
 114   6                              {
 115   7                                  __rf_data <<= 1; // ç”¨äºŽå­˜æ”¾æŽ¥æ”¶24ä½æ•°æ®çš„å˜é‡å·¦ç§»ä¸€ä½
 116   7                              }
 117   6                          }
 118   5                          else if (flag_is_enable_recv &&
 119   5                                   low_level_cnt >= 7 && low_level_cnt < 20 &&
 120   5                                   high_level_cnt >= 1 && high_level_cnt < 6)
 121   5                          {
 122   6                              // å¦‚æžœä½Žç”µå¹³æŒç»­æ—¶é—´åœ¨840uså·¦å³ï¼Œé«˜ç”µå¹³æŒç»­æ—¶é—´åœ¨360uså·¦å³
             -ï¼Œè¯´æ˜ŽæŽ¥æ”¶åˆ°äº†0
 123   6                              __rf_data &= ~1;
 124   6                              rf_bit_cnt++;
 125   6                              if (rf_bit_cnt != 24)
 126   6                              {
 127   7                                  __rf_data <<= 1; // ç”¨äºŽå­˜æ”¾æŽ¥æ”¶24ä½æ•°æ®çš„å˜é‡å·¦ç§»ä¸€ä½
 128   7                              }
 129   6                          }
 130   5                          else
 131   5                          {
 132   6                              // å¦‚æžœä½Žç”µå¹³æŒç»­æ—¶é—´ä¸ç¬¦åˆ0å’Œ1çš„åˆ¤æ–­æ¡ä»¶ï¼Œè¯´æ˜Žæ­¤æ—¶æ²¡æœ‰æŽ
             -¥æ”¶åˆ°ä¿¡å·
 133   6                              __rf_data = 0;
 134   6                              rf_bit_cnt = 0;
 135   6                              flag_is_enable_recv = 0;
 136   6                          }
 137   5      
 138   5                          low_level_cnt = 0; // æ— è®ºæ˜¯å¦æŽ¥æ”¶åˆ°ä¸€ä½æ•°æ®ï¼Œé‡åˆ°é«˜ç”µå¹³æ—¶ï¼Œå…ˆæ¸…é
             -™¤ä¹‹å‰çš„è®¡æ•°å€¼
 139   5                          high_level_cnt = 0;
 140   5      
 141   5                          if (24 == rf_bit_cnt)
 142   5                          {
 143   6                              // å¦‚æžœæŽ¥æ”¶æˆäº†24ä½çš„æ•°æ®
 144   6                              __flag_is_recved_data = 1; // æŽ¥æ”¶å®Œæˆæ ‡å¿—ä½ç½®ä¸€
 145   6                              flag_is_enable_recv = 0;
 146   6                          }
 147   5                      }
 148   4                      else
 149   4                      {
 150   5                          // å¦‚æžœæŽ¥æ”¶åˆ°é«˜ç”µå¹³åŽï¼Œä½Žç”µå¹³çš„è®¡æ•°ä¸º0
 151   5      
 152   5                          if (0 == flag_is_enable_recv)
 153   5                          {
 154   6                              __rf_data = 0;
 155   6                              rf_bit_cnt = 0;
 156   6                              flag_is_enable_recv = 0;
 157   6                          }
 158   5                      }
 159   4      
 160   4                      // å¦‚æžœRFæŽ¥æ”¶å¼•è„šä¸ºé«˜ç”µå¹³ï¼Œè®°å½•é«˜ç”µå¹³çš„æŒç»­æ—¶é—´
 161   4                      high_level_cnt++;
 162   4                  }
 163   3      
 164   3                  if (__flag_is_recved_data) //
C51 COMPILER V9.60.7.0   TIMER2                                                            02/05/2026 15:20:24 PAGE 4   

 165   3                  {
 166   4                      rf_bit_cnt = 0;
 167   4                      __flag_is_recved_data = 0;
 168   4                      low_level_cnt = 0;
 169   4                      high_level_cnt = 0;
 170   4      
 171   4                      // if (rf_data != 0)
 172   4                      // if (0 == flag_is_recved_rf_data) /* å¦‚æžœä¹‹å‰æœªæŽ¥æ”¶åˆ°æ•°æ® æˆ–æ˜¯ å·²ç»å¤„ç†å
             -®Œä¸Šä¸€æ¬¡æŽ¥æ”¶åˆ°çš„æ•°æ® */
 173   4                      {
 174   5                          // çŽ°åœ¨æ”¹ä¸ºåªè¦æ”¶åˆ°æ–°çš„æ•°æ®ï¼Œå°±è¦†ç›–rf_data
 175   5                          rf_data = __rf_data;
 176   5                          flag_is_recved_rf_data = 1;
 177   5                      }
 178   4                      // else
 179   4                      // {
 180   4                      //     __rf_data = 0;
 181   4                      // }
 182   4                  }
 183   3              }
 184   2      #endif // rfä¿¡å·æŽ¥æ”¶ ï¼ˆ100usè°ƒç”¨ä¸€æ¬¡ï¼‰
 185   2      
 186   2      #if 1 // è°ƒèŠ‚PWMå ç©ºæ¯”
 187   2            // if (pwm_duty_change_cnt >= 10) // 1000us,1ms
 188   2              // if (pwm_duty_change_cnt >= 1) // 100usï¼ˆç”¨é¥æŽ§å™¨è°ƒèŠ‚ï¼Œåœ¨50%ä»¥ä¸Šè°ƒèŠ‚pwmå ç©ºæ¯”çš„
             -æ—¶å€™ï¼Œç¯å…‰ä¼šæœ‰æŠ–åŠ¨ï¼‰
 189   2              // if (pwm_duty_change_cnt >= 5) // 500us
 190   2              // if (pwm_duty_change_cnt >= 10) // x * 100us ï¼ˆç”¨é¥æŽ§å™¨è°ƒèŠ‚åˆ°50%ä»¥ä¸‹pwmå ç©ºæ¯”çš„æ—¶
             -å€™ï¼Œç¯å…‰ä¼šæœ‰æŠ–åŠ¨ï¼‰
 191   2              if (pwm_duty_change_cnt >= 20) // x * 100us ï¼ˆ ç”¨é¥æŽ§å™¨è°ƒèŠ‚æ—¶ï¼Œç¯å…‰ä¸ä¼šæœ‰æŠ–åŠ¨ï¼Œæ 
             -·æœºæœ€é«˜åŠŸçŽ‡ä¸º870W--åŠ ä¸Šé£Žæ‰‡ï¼‰
 192   2              // if (pwm_duty_change_cnt >= 30) // x * 100us ï¼ˆç”¨é¥æŽ§å™¨è°ƒèŠ‚æ—¶ï¼Œç¯å…‰ä¸ä¼šæœ‰æŠ–åŠ¨ï¼Œ
             -ä½†æ˜¯è°ƒèŠ‚æ—¶é—´è¿‡é•¿ï¼Œæ„Ÿè§‰ä¸è·Ÿæ‰‹ï¼‰
 193   2              {
 194   3      
 195   3                  pwm_duty_change_cnt = 0;
 196   3      
 197   3                  if (0 == flag_is_in_power_on) // ä¸å¤„äºŽå¼€æœºç¼“å¯åŠ¨ï¼Œæ‰ä½¿èƒ½PWMå ç©ºæ¯”è°ƒèŠ‚
 198   3                  {
 199   4                      // =================================================================
 200   4                      // pwm_channel_0                                               //
 201   4                      // =================================================================
 202   4                      if (adjust_pwm_channel_0_duty > cur_pwm_channel_0_duty)
 203   4                      {
 204   5                          cur_pwm_channel_0_duty++;
 205   5                      }
 206   4                      else if (adjust_pwm_channel_0_duty < cur_pwm_channel_0_duty)
 207   4                      {
 208   5                          cur_pwm_channel_0_duty--;
 209   5                      }
 210   4      
 211   4                      // =================================================================
 212   4                      // pwm_channel_1                                               //
 213   4                      // =================================================================
 214   4                      if (adjust_pwm_channel_1_duty > cur_pwm_channel_1_duty)
 215   4                      {
 216   5                          cur_pwm_channel_1_duty++;
 217   5                      }
 218   4                      else if (adjust_pwm_channel_1_duty < cur_pwm_channel_1_duty)
 219   4                      {
 220   5                          cur_pwm_channel_1_duty--;
 221   5                      }
C51 COMPILER V9.60.7.0   TIMER2                                                            02/05/2026 15:20:24 PAGE 5   

 222   4      
 223   4                      set_pwm_channel_0_duty(cur_pwm_channel_0_duty);
 224   4                      set_pwm_channel_1_duty(cur_pwm_channel_1_duty);
 225   4      
 226   4                      if (cur_pwm_channel_0_duty <= 0)
 227   4                      {
 228   5                          // å°äºŽæŸä¸ªå€¼ï¼Œç›´æŽ¥è¾“å‡º0%å ç©ºæ¯”ï¼Œå…³é—­PWMè¾“å‡ºï¼Œå¼•è„šé…ç½®ä¸ºè¾“å‡º
             -æ¨¡å¼
 229   5                          pwm_channel_0_disable();
 230   5                      }
 231   4                      else // å¦‚æžœå¤§äºŽ0
 232   4                      {
 233   5                          pwm_channel_0_enable();
 234   5                      }
 235   4      
 236   4                      if (cur_pwm_channel_1_duty <= 0)
 237   4                      {
 238   5                          // å°äºŽæŸä¸ªå€¼ï¼Œç›´æŽ¥è¾“å‡º0%å ç©ºæ¯”ï¼Œå…³é—­PWMè¾“å‡ºï¼Œå¼•è„šé…ç½®ä¸ºè¾“å‡º
             -æ¨¡å¼
 239   5                          pwm_channel_1_disable();
 240   5                      }
 241   4                      else // å¦‚æžœå¤§äºŽ0
 242   4                      {
 243   5                          pwm_channel_1_enable();
 244   5                      }
 245   4      
 246   4                  } // if (0 == flag_is_in_power_on) // ä¸å¤„äºŽå¼€æœºç¼“å¯åŠ¨ï¼Œæ‰ä½¿èƒ½PWMå ç©ºæ¯”è°ƒèŠ‚
 247   3      
 248   3      #if 0
                          // printf("c_duty %u\n", c_duty);
                          // printf(",c=%u\n", c_duty);
              #endif
 252   3              }
 253   2      #endif // è°ƒèŠ‚PWMå ç©ºæ¯”
 254   2          }
 255   1      
 256   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 257   1          __IRQnIPnPop(TMR2_IRQn);
 258   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    714    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     15    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
