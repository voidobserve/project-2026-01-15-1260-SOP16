C51 COMPILER V9.60.7.0   TIME0                                                             02/05/2026 15:20:23 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIME0
OBJECT MODULE PLACED IN .\Release\Objects\time0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\time0.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDI
                    -R(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\time0.lst) OBJECT(.\Releas
                    -e\Objects\time0.obj)

line level    source

   1          #include "time0.h"
   2          #include "power_on.h"
   3          
   4          // u8 ms_cnt = 0;
   5          // volatile bit tmr0_flag = 0;
   6          
   7          // static volatile u8 cnt_during_power_on = 0; // 开机缓启动，调节pwm占空比时，使用到的
             -数值
   8          // volatile bit flag_time_comes_during_power_on = 0; // 标志位，开机缓启动期间，调节时间
             -来
   9          
  10          /**
  11           * @brief 配置定时器TMR0，定时器默认关闭
  12           */
  13          void tmr0_config(void)
  14          {
  15   1          __EnableIRQ(TMR0_IRQn); // 使能timer0中断
  16   1          IE_EA = 1;              // 使能总中断
  17   1      
  18   1      #define PEROID_VAL (SYSCLK / 128 / 1000 - 1) // 周期值=系统时钟/分频/频率 - 1
  19   1          // 设置timer0的计数功能，配置一个频率为1kHz的中断
  20   1          TMR_ALLCON = TMR0_CNT_CLR(0x1);                        // 清除计数值
  21   1          TMR0_PRH = TMR_PERIOD_VAL_H((PEROID_VAL >> 8) & 0xFF); // 周期值
  22   1          TMR0_PRL = TMR_PERIOD_VAL_L((PEROID_VAL >> 0) & 0xFF);
  23   1          TMR0_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // 计数等于周期时
             -许发生中断
  24   1          TMR0_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // 选择系统时钟，1
             -28分频，计数模式
  25   1      }
  26          
  27          // /**
  28          //  * @brief 开启定时器TMR0，开始计时
  29          //  */
  30          // void tmr0_enable(void)
  31          // {
  32          //     // 重新给TMR0配置时钟
  33          //     TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  34          //     TMR0_CONL |= TMR_SOURCE_SEL(0x06);    // 配置定时器的时钟源，使用系统时钟（约21MH
             -z）
  35          
  36          //     __EnableIRQ(TMR0_IRQn); // 使能中断
  37          //     IE_EA = 1;              // 打开总中断
  38          // }
  39          
  40          // /**
  41          //  * @brief 关闭定时器0，清空计数值
  42          //  */
  43          // void tmr0_disable(void)
  44          // {
  45          //     // 不给定时器提供时钟，让它停止计数
  46          //     TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  47          //     TMR0_CONL |= TMR_SOURCE_SEL(0x05);    // 配置定时器的时钟源，不用任何时钟
  48          
C51 COMPILER V9.60.7.0   TIME0                                                             02/05/2026 15:20:23 PAGE 2   

  49          //     // 清除定时器的计数值
  50          //     TMR0_CNTL = 0;
  51          //     TMR0_CNTH = 0;
  52          
  53          //     __DisableIRQ(TMR0_IRQn); // 关闭中断（不使能中断）
  54          // }
  55          
  56          // extern void fun(void);
  57          // 定时器TMR0中断服务函数
  58          void TIMR0_IRQHandler(void) interrupt TMR0_IRQn
  59          {
  60   1          // 进入中断设置IP，不可删除
  61   1          __IRQnIPnPush(TMR0_IRQn);
  62   1      
  63   1          // ---------------- 用户函数处理 -------------------
  64   1      
  65   1          // 周期中断
  66   1          if (TMR0_CONH & TMR_PRD_PND(0x1))
  67   1          {
  68   2              TMR0_CONH |= TMR_PRD_PND(0x1); // 清除pending
  69   2              // cnt_during_power_on++;
  70   2      
  71   2              // if (cnt_during_power_on >= 13) // 13ms
  72   2              // {
  73   2              //     cnt_during_power_on = 0;
  74   2              //     flag_time_comes_during_power_on = 1; // 开机缓启动期间，控制每次调节PWM占空
             -比的时间
  75   2              // }
  76   2      
  77   2              flag_time_comes_during_power_on = 1; // 开机缓启动期间，控制每次调节PWM占空比的
             -间
  78   2      
  79   2              if (rf_key_para.cur_scan_times < 255)
  80   2              {
  81   3                  rf_key_para.cur_scan_times++; // 用于433遥控器按键扫描
  82   3              }
  83   2      
  84   2              { // rf对码功能计时，从 上电后 到 RF_LEARN_TIMES期间，使能对码功能
  85   3                  static u16 rf_learn_cnt = 0;
  86   3      
  87   3                  if (flag_is_rf_enable && flag_is_in_rf_learning)
  88   3                  {
  89   4                      rf_learn_cnt++;
  90   4                      if (rf_learn_cnt >= RF_LEARN_TIMES)
  91   4                      {
  92   5                          rf_learn_cnt = 0;
  93   5                          flag_is_in_rf_learning = 0;
  94   5                      }
  95   4                  }
  96   3                  else
  97   3                  {
  98   4                      rf_learn_cnt = 0;
  99   4                  }
 100   3              }
 101   2      
 102   2              { // 风扇状态检测，累计一段时间后更新状态
 103   3                  static u16 fan_normal_cnt = 0;
 104   3                  static u16 fan_err_cnt = 0;
 105   3      
 106   3                  if (flag_tim_scan_fan_is_err) // 如果检测到了风扇异常
 107   3                  {
 108   4                      fan_err_cnt++;
C51 COMPILER V9.60.7.0   TIME0                                                             02/05/2026 15:20:23 PAGE 3   

 109   4                      fan_normal_cnt = 0;
 110   4      
 111   4                      if (fan_err_cnt >= FAN_SCAN_TIMES_WHEN_ERR)
 112   4                      {
 113   5                          fan_err_cnt = 0;
 114   5                          cur_fan_status = FAN_STATUS_ERROR;
 115   5                      }
 116   4                  }
 117   3                  else
 118   3                  {
 119   4                      fan_normal_cnt++;
 120   4                      fan_err_cnt = 0;
 121   4      
 122   4                      if (fan_normal_cnt >= FAN_SCAN_TIMES_WHEN_NORMAL)
 123   4                      {
 124   5                          fan_normal_cnt = 0;
 125   5                          cur_fan_status = FAN_STATUS_NORMAL;
 126   5                      }
 127   4                  }
 128   3              } // 风扇状态检测，累计一段时间后更新状态
 129   2      
 130   2              { // 用于上电多久之后，限制PWM最大的占空比
 131   3                  static u32 cnt = 0;
 132   3                  if (0 == flag_is_time_to_limit_pwm)
 133   3                  {
 134   4                      /*
 135   4                          如果没有到到限制占空比的时间（标志位不为1）
 136   4                          则进行计时
 137   4                      */
 138   4                      cnt++;
 139   4                      if (cnt >= SCHEDULE_TIME_TO_LIMIT_PWM)
 140   4                      {
 141   5                          cnt = 0;
 142   5                          flag_is_time_to_limit_pwm = 1;
 143   5                      }
 144   4                  }
 145   3              }
 146   2          }
 147   1      
 148   1          // 退出中断设置IP，不可删除
 149   1          __IRQnIPnPop(TMR0_IRQn);
 150   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    302    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
