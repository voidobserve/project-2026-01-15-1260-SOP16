C51 COMPILER V9.60.7.0   TIME0                                                             01/24/2026 18:08:45 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIME0
OBJECT MODULE PLACED IN .\Release\Objects\time0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\time0.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDI
                    -R(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\time0.lst) OBJECT(.\Releas
                    -e\Objects\time0.obj)

line level    source

   1          #include "time0.h"
   2          
   3          #include "pwm.h"
   4          
   5          // u8 ms_cnt = 0;
   6          // volatile bit tmr0_flag = 0;
   7          
   8          static volatile u8 cnt_during_power_on = 0; // ÂºÄÊú∫ÁºìÂêØÂä®ÔºåË∞ÉËäÇpwmÂç†Á©∫ÊØîÊó∂Ôºå‰ΩøÁî®Âà∞ÁöÑËÆ°Êï
             -∞ÂÄº
   9          // volatile bit flag_time_comes_during_power_on = 0; // Ê†áÂøó‰ΩçÔºåÂºÄÊú∫ÁºìÂêØÂä®ÊúüÈó¥ÔºåË∞ÉËäÇÊó∂Èó¥Âà
             -∞Êù•
  10          
  11          /**
  12           * @brief ÈÖçÁΩÆÂÆöÊó∂Âô®TMR0ÔºåÂÆöÊó∂Âô®ÈªòËÆ§ÂÖ≥Èó≠
  13           */
  14          void tmr0_config(void)
  15          {
  16   1          __EnableIRQ(TMR0_IRQn); // ‰ΩøËÉΩtimer0‰∏≠Êñ≠
  17   1          IE_EA = 1;              // ‰ΩøËÉΩÊÄª‰∏≠Êñ≠
  18   1      
  19   1      #define PEROID_VAL (SYSCLK / 128 / 1000 - 1) // Âë®ÊúüÂÄº=Á≥ªÁªüÊó∂Èíü/ÂàÜÈ¢ë/È¢ëÁéá - 1
  20   1          // ËÆæÁΩÆtimer0ÁöÑËÆ°Êï∞ÂäüËÉΩÔºåÈÖçÁΩÆ‰∏Ä‰∏™È¢ëÁéá‰∏∫1kHzÁöÑ‰∏≠Êñ≠
  21   1          TMR_ALLCON = TMR0_CNT_CLR(0x1);                        // Ê∏ÖÈô§ËÆ°Êï∞ÂÄº
  22   1          TMR0_PRH = TMR_PERIOD_VAL_H((PEROID_VAL >> 8) & 0xFF); // Âë®ÊúüÂÄº
  23   1          TMR0_PRL = TMR_PERIOD_VAL_L((PEROID_VAL >> 0) & 0xFF);
  24   1          TMR0_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // ËÆ°Êï∞Á≠â‰∫éÂë®ÊúüÊó∂Â
             -ÖÅËÆ∏ÂèëÁîü‰∏≠Êñ≠
  25   1          TMR0_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // ÈÄâÊã©Á≥ªÁªüÊó∂ÈíüÔºå1
             -28ÂàÜÈ¢ëÔºåËÆ°Êï∞Ê®°Âºè
  26   1      }
  27          
  28          // /**
  29          //  * @brief ÂºÄÂêØÂÆöÊó∂Âô®TMR0ÔºåÂºÄÂßãËÆ°Êó∂
  30          //  */
  31          // void tmr0_enable(void)
  32          // {
  33          //     // ÈáçÊñ∞ÁªôTMR0ÈÖçÁΩÆÊó∂Èíü
  34          //     TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // Ê∏ÖÈô§ÂÆöÊó∂Âô®ÁöÑÊó∂ÈíüÊ∫êÈÖçÁΩÆÂØÑÂ≠òÂô®
  35          //     TMR0_CONL |= TMR_SOURCE_SEL(0x06);    // ÈÖçÁΩÆÂÆöÊó∂Âô®ÁöÑÊó∂ÈíüÊ∫êÔºå‰ΩøÁî®Á≥ªÁªüÊó∂ÈíüÔºàÁ∫¶21MH
             -zÔºâ
  36          
  37          //     __EnableIRQ(TMR0_IRQn); // ‰ΩøËÉΩ‰∏≠Êñ≠
  38          //     IE_EA = 1;              // ÊâìÂºÄÊÄª‰∏≠Êñ≠
  39          // }
  40          
  41          // /**
  42          //  * @brief ÂÖ≥Èó≠ÂÆöÊó∂Âô®0ÔºåÊ∏ÖÁ©∫ËÆ°Êï∞ÂÄº
  43          //  */
  44          // void tmr0_disable(void)
  45          // {
  46          //     // ‰∏çÁªôÂÆöÊó∂Âô®Êèê‰æõÊó∂ÈíüÔºåËÆ©ÂÆÉÂÅúÊ≠¢ËÆ°Êï∞
  47          //     TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // Ê∏ÖÈô§ÂÆöÊó∂Âô®ÁöÑÊó∂ÈíüÊ∫êÈÖçÁΩÆÂØÑÂ≠òÂô®
  48          //     TMR0_CONL |= TMR_SOURCE_SEL(0x05);    // ÈÖçÁΩÆÂÆöÊó∂Âô®ÁöÑÊó∂ÈíüÊ∫êÔºå‰∏çÁî®‰ªª‰ΩïÊó∂Èíü
C51 COMPILER V9.60.7.0   TIME0                                                             01/24/2026 18:08:45 PAGE 2   

  49          
  50          //     // Ê∏ÖÈô§ÂÆöÊó∂Âô®ÁöÑËÆ°Êï∞ÂÄº
  51          //     TMR0_CNTL = 0;
  52          //     TMR0_CNTH = 0;
  53          
  54          //     __DisableIRQ(TMR0_IRQn); // ÂÖ≥Èó≠‰∏≠Êñ≠Ôºà‰∏ç‰ΩøËÉΩ‰∏≠Êñ≠Ôºâ
  55          // }
  56          
  57          // extern void fun(void);
  58          // ÂÆöÊó∂Âô®TMR0‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞
  59          void TIMR0_IRQHandler(void) interrupt TMR0_IRQn
  60          {
  61   1          // ËøõÂÖ•‰∏≠Êñ≠ËÆæÁΩÆIPÔºå‰∏çÂèØÂà†Èô§
  62   1          __IRQnIPnPush(TMR0_IRQn);
  63   1      
  64   1          // ---------------- Áî®Êà∑ÂáΩÊï∞Â§ÑÁêÜ -------------------
  65   1      
  66   1          // Âë®Êúü‰∏≠Êñ≠
  67   1          if (TMR0_CONH & TMR_PRD_PND(0x1))
  68   1          {
  69   2              TMR0_CONH |= TMR_PRD_PND(0x1); // Ê∏ÖÈô§pending
  70   2              // cnt_during_power_on++;
  71   2      
  72   2              // if (cnt_during_power_on >= 13) // 13ms
  73   2              // {
  74   2              //     cnt_during_power_on = 0;
  75   2              //     flag_time_comes_during_power_on = 1; // ÂºÄÊú∫ÁºìÂêØÂä®ÊúüÈó¥ÔºåÊéßÂà∂ÊØèÊ¨°Ë∞ÉËäÇPWMÂç†Á©∫
             -ÊØîÁöÑÊó∂Èó¥
  76   2              // }
  77   2      
  78   2              flag_time_comes_during_power_on = 1;
  79   2      
  80   2              if (rf_key_para.cur_scan_times < 255)
  81   2              {
  82   3                  rf_key_para.cur_scan_times++; // Áî®‰∫é433ÈÅ•ÊéßÂô®ÊåâÈîÆÊâ´Êèè
  83   3              }
  84   2      
  85   2              { // rfÂØπÁ†ÅÂäüËÉΩËÆ°Êó∂Ôºå‰ªé ‰∏äÁîµÂêé Âà∞ RF_LEARN_TIMESÊúüÈó¥Ôºå‰ΩøËÉΩÂØπÁ†ÅÂäüËÉΩ
  86   3                  static u16 rf_learn_cnt = 0;
  87   3      
  88   3                  if (flag_is_rf_enable && flag_is_in_rf_learning)
  89   3                  {
  90   4                      rf_learn_cnt++;
  91   4                      if (rf_learn_cnt >= RF_LEARN_TIMES)
  92   4                      {
  93   5                          rf_learn_cnt = 0;
  94   5                          flag_is_in_rf_learning = 0;
  95   5                      }
  96   4                  }
  97   3                  else
  98   3                  {
  99   4                      rf_learn_cnt = 0;
 100   4                  }
 101   3              }
 102   2      
 103   2              { // È£éÊâáÁä∂ÊÄÅÊ£ÄÊµãÔºåÁ¥ØËÆ°‰∏ÄÊÆµÊó∂Èó¥ÂêéÊõ¥Êñ∞Áä∂ÊÄÅ
 104   3                  static u16 fan_normal_cnt = 0;
 105   3                  static u16 fan_err_cnt = 0;
 106   3      
 107   3                  if (flag_tim_scan_fan_is_err) // Â¶ÇÊûúÊ£ÄÊµãÂà∞‰∫ÜÈ£éÊâáÂºÇÂ∏∏
 108   3                  {
 109   4                      fan_err_cnt++;
C51 COMPILER V9.60.7.0   TIME0                                                             01/24/2026 18:08:45 PAGE 3   

 110   4                      fan_normal_cnt = 0;
 111   4      
 112   4                      if (fan_err_cnt >= FAN_SCAN_TIMES_WHEN_ERR)
 113   4                      {
 114   5                          fan_err_cnt = 0;
 115   5                          cur_fan_status = FAN_STATUS_ERROR;
 116   5                      }
 117   4                  }
 118   3                  else
 119   3                  {
 120   4                      fan_normal_cnt++;
 121   4                      fan_err_cnt = 0;
 122   4      
 123   4                      if (fan_normal_cnt >= FAN_SCAN_TIMES_WHEN_NORMAL)
 124   4                      {
 125   5                          fan_normal_cnt = 0;
 126   5                          cur_fan_status = FAN_STATUS_NORMAL;
 127   5                      }
 128   4                  }
 129   3              } // È£éÊâáÁä∂ÊÄÅÊ£ÄÊµãÔºåÁ¥ØËÆ°‰∏ÄÊÆµÊó∂Èó¥ÂêéÊõ¥Êñ∞Áä∂ÊÄÅ
 130   2      
 131   2              // {
 132   2              //     static volatile u32 cnt = 0;
 133   2      
 134   2              //     if (TEMP_75 == temp_status)
 135   2              //     {
 136   2              //         cnt++;
 137   2              //         if (cnt >= (u32)TMR1_CNT_5_MINUTES)
 138   2              //         {
 139   2      
 140   2              //         }
 141   2              //     }
 142   2              // }
 143   2      
 144   2              { // Áî®‰∫é‰∏äÁîµÂ§ö‰πÖ‰πãÂêéÔºåÈôêÂà∂PWMÊúÄÂ§ßÁöÑÂç†Á©∫ÊØî
 145   3                  static u32 cnt = 0;
 146   3                  if (0 == flag_is_time_to_limit_pwm)
 147   3                  {
 148   4                      /*
 149   4                          Â¶ÇÊûúÊ≤°ÊúâÂà∞Âà∞ÈôêÂà∂Âç†Á©∫ÊØîÁöÑÊó∂Èó¥ÔºàÊ†áÂøó‰Ωç‰∏ç‰∏∫1Ôºâ
 150   4                          ÂàôËøõË°åËÆ°Êó∂
 151   4                      */
 152   4                      cnt++;
 153   4                      if (cnt >= SCHEDULE_TIME_TO_LIMIT_PWM)
 154   4                      {
 155   5                          cnt = 0;
 156   5                          flag_is_time_to_limit_pwm = 1;
 157   5                      }
 158   4                  }
 159   3              }
 160   2          }
 161   1      
 162   1          // ÈÄÄÂá∫‰∏≠Êñ≠ËÆæÁΩÆIPÔºå‰∏çÂèØÂà†Èô§
 163   1          __IRQnIPnPop(TMR0_IRQn);
 164   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    302    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   TIME0                                                             01/24/2026 18:08:45 PAGE 4   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
