C51 COMPILER V9.60.7.0   TIME0                                                             01/24/2026 17:50:51 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIME0
OBJECT MODULE PLACED IN .\Release\Objects\time0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\time0.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDI
                    -R(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\time0.lst) OBJECT(.\Releas
                    -e\Objects\time0.obj)

line level    source

   1          #include "time0.h"
   2          
   3          #include "pwm.h"
   4          
   5          // u8 ms_cnt = 0;
   6          // volatile bit tmr0_flag = 0;
   7          
   8          static volatile u8 cnt_during_power_on = 0;       // ÂºÄÊú∫ÁºìÂêØÂä®ÔºåË∞ÉËäÇpwmÂç†Á©∫ÊØîÊó∂Ôºå‰ΩøÁî®Âà∞Áö
             -ÑËÆ°Êï∞ÂÄº
   9          volatile bit flag_time_comes_during_power_on = 0; // Ê†áÂøó‰ΩçÔºåÂºÄÊú∫ÁºìÂêØÂä®ÊúüÈó¥ÔºåË∞ÉËäÇÊó∂Èó¥Âà∞Êù
             -•
  10          
  11          /**
  12           * @brief ÈÖçÁΩÆÂÆöÊó∂Âô®TMR0ÔºåÂÆöÊó∂Âô®ÈªòËÆ§ÂÖ≥Èó≠
  13           */
  14          void tmr0_config(void)
  15          {
  16   1          __EnableIRQ(TMR0_IRQn); // ‰ΩøËÉΩtimer0‰∏≠Êñ≠
  17   1          IE_EA = 1;              // ‰ΩøËÉΩÊÄª‰∏≠Êñ≠
  18   1      
  19   1      #define PEROID_VAL (SYSCLK / 128 / 1000 - 1) // Âë®ÊúüÂÄº=Á≥ªÁªüÊó∂Èíü/ÂàÜÈ¢ë/È¢ëÁéá - 1
  20   1          // ËÆæÁΩÆtimer0ÁöÑËÆ°Êï∞ÂäüËÉΩÔºåÈÖçÁΩÆ‰∏Ä‰∏™È¢ëÁéá‰∏∫1kHzÁöÑ‰∏≠Êñ≠
  21   1          TMR_ALLCON = TMR0_CNT_CLR(0x1);                        // Ê∏ÖÈô§ËÆ°Êï∞ÂÄº
  22   1          TMR0_PRH = TMR_PERIOD_VAL_H((PEROID_VAL >> 8) & 0xFF); // Âë®ÊúüÂÄº
  23   1          TMR0_PRL = TMR_PERIOD_VAL_L((PEROID_VAL >> 0) & 0xFF);
  24   1          TMR0_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // ËÆ°Êï∞Á≠â‰∫éÂë®ÊúüÊó∂Â
             -ÖÅËÆ∏ÂèëÁîü‰∏≠Êñ≠
  25   1          TMR0_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // ÈÄâÊã©Á≥ªÁªüÊó∂ÈíüÔºå1
             -28ÂàÜÈ¢ëÔºåËÆ°Êï∞Ê®°Âºè
  26   1      }
  27          
  28          // /**
  29          //  * @brief ÂºÄÂêØÂÆöÊó∂Âô®TMR0ÔºåÂºÄÂßãËÆ°Êó∂
  30          //  */
  31          // void tmr0_enable(void)
  32          // {
  33          //     // ÈáçÊñ∞ÁªôTMR0ÈÖçÁΩÆÊó∂Èíü
  34          //     TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // Ê∏ÖÈô§ÂÆöÊó∂Âô®ÁöÑÊó∂ÈíüÊ∫êÈÖçÁΩÆÂØÑÂ≠òÂô®
  35          //     TMR0_CONL |= TMR_SOURCE_SEL(0x06);    // ÈÖçÁΩÆÂÆöÊó∂Âô®ÁöÑÊó∂ÈíüÊ∫êÔºå‰ΩøÁî®Á≥ªÁªüÊó∂ÈíüÔºàÁ∫¶21MH
             -zÔºâ
  36          
  37          //     __EnableIRQ(TMR0_IRQn); // ‰ΩøËÉΩ‰∏≠Êñ≠
  38          //     IE_EA = 1;              // ÊâìÂºÄÊÄª‰∏≠Êñ≠
  39          // }
  40          
  41          // /**
  42          //  * @brief ÂÖ≥Èó≠ÂÆöÊó∂Âô®0ÔºåÊ∏ÖÁ©∫ËÆ°Êï∞ÂÄº
  43          //  */
  44          // void tmr0_disable(void)
  45          // {
  46          //     // ‰∏çÁªôÂÆöÊó∂Âô®Êèê‰æõÊó∂ÈíüÔºåËÆ©ÂÆÉÂÅúÊ≠¢ËÆ°Êï∞
  47          //     TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // Ê∏ÖÈô§ÂÆöÊó∂Âô®ÁöÑÊó∂ÈíüÊ∫êÈÖçÁΩÆÂØÑÂ≠òÂô®
  48          //     TMR0_CONL |= TMR_SOURCE_SEL(0x05);    // ÈÖçÁΩÆÂÆöÊó∂Âô®ÁöÑÊó∂ÈíüÊ∫êÔºå‰∏çÁî®‰ªª‰ΩïÊó∂Èíü
C51 COMPILER V9.60.7.0   TIME0                                                             01/24/2026 17:50:51 PAGE 2   

  49          
  50          //     // Ê∏ÖÈô§ÂÆöÊó∂Âô®ÁöÑËÆ°Êï∞ÂÄº
  51          //     TMR0_CNTL = 0;
  52          //     TMR0_CNTH = 0;
  53          
  54          //     __DisableIRQ(TMR0_IRQn); // ÂÖ≥Èó≠‰∏≠Êñ≠Ôºà‰∏ç‰ΩøËÉΩ‰∏≠Êñ≠Ôºâ
  55          // }
  56          
  57          // extern void fun(void);
  58          // ÂÆöÊó∂Âô®TMR0‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞
  59          void TIMR0_IRQHandler(void) interrupt TMR0_IRQn
  60          {
  61   1          // ËøõÂÖ•‰∏≠Êñ≠ËÆæÁΩÆIPÔºå‰∏çÂèØÂà†Èô§
  62   1          __IRQnIPnPush(TMR0_IRQn);
  63   1      
  64   1          // ---------------- Áî®Êà∑ÂáΩÊï∞Â§ÑÁêÜ -------------------
  65   1      
  66   1          // Âë®Êúü‰∏≠Êñ≠
  67   1          if (TMR0_CONH & TMR_PRD_PND(0x1))
  68   1          {
  69   2              TMR0_CONH |= TMR_PRD_PND(0x1); // Ê∏ÖÈô§pending
  70   2      
  71   2              // ms_cnt++;
  72   2              cnt_during_power_on++;
  73   2      
  74   2              // if (ms_cnt >= 25)
  75   2              // {
  76   2              //     ms_cnt = 0;
  77   2              //     // tmr0_flag = 1;
  78   2              // }
  79   2      
  80   2              if (cnt_during_power_on >= 13) // 13ms
  81   2              {
  82   3                  cnt_during_power_on = 0;
  83   3                  flag_time_comes_during_power_on = 1; // ÂºÄÊú∫ÁºìÂêØÂä®ÊúüÈó¥ÔºåÊéßÂà∂ÊØèÊ¨°Ë∞ÉËäÇPWMÂç†Á©∫ÊØî
             -ÁöÑÊó∂Èó¥
  84   3              }
  85   2      
  86   2              if (rf_key_para.cur_scan_times < 255)
  87   2              {
  88   3                  rf_key_para.cur_scan_times++; // Áî®‰∫é433ÈÅ•ÊéßÂô®ÊåâÈîÆÊâ´Êèè
  89   3              }
  90   2      
  91   2              { // rfÂØπÁ†ÅÂäüËÉΩËÆ°Êó∂Ôºå‰ªé ‰∏äÁîµÂêé Âà∞ RF_LEARN_TIMESÊúüÈó¥Ôºå‰ΩøËÉΩÂØπÁ†ÅÂäüËÉΩ
  92   3                  static u16 rf_learn_cnt = 0;
  93   3      
  94   3                  if (flag_is_rf_enable && flag_is_in_rf_learning)
  95   3                  {
  96   4                      rf_learn_cnt++;
  97   4                      if (rf_learn_cnt >= RF_LEARN_TIMES)
  98   4                      {
  99   5                          rf_learn_cnt = 0;
 100   5                          flag_is_in_rf_learning = 0;
 101   5                      }
 102   4                  }
 103   3                  else
 104   3                  {
 105   4                      rf_learn_cnt = 0;
 106   4                  }
 107   3              }
 108   2      
 109   2              { // È£éÊâáÁä∂ÊÄÅÊ£ÄÊµãÔºåÁ¥ØËÆ°‰∏ÄÊÆµÊó∂Èó¥ÂêéÊõ¥Êñ∞Áä∂ÊÄÅ
C51 COMPILER V9.60.7.0   TIME0                                                             01/24/2026 17:50:51 PAGE 3   

 110   3                  static u16 fan_normal_cnt = 0;
 111   3                  static u16 fan_err_cnt = 0;
 112   3      
 113   3                  if (flag_tim_scan_fan_is_err) // Â¶ÇÊûúÊ£ÄÊµãÂà∞‰∫ÜÈ£éÊâáÂºÇÂ∏∏
 114   3                  {
 115   4                      fan_err_cnt++;
 116   4                      fan_normal_cnt = 0;
 117   4      
 118   4                      if (fan_err_cnt >= FAN_SCAN_TIMES_WHEN_ERR)
 119   4                      {
 120   5                          fan_err_cnt = 0;
 121   5                          cur_fan_status = FAN_STATUS_ERROR;
 122   5                      }
 123   4                  }
 124   3                  else
 125   3                  {
 126   4                      fan_normal_cnt++;
 127   4                      fan_err_cnt = 0;
 128   4      
 129   4                      if (fan_normal_cnt >= FAN_SCAN_TIMES_WHEN_NORMAL)
 130   4                      {
 131   5                          fan_normal_cnt = 0;
 132   5                          cur_fan_status = FAN_STATUS_NORMAL;
 133   5                      }
 134   4                  }
 135   3              } // È£éÊâáÁä∂ÊÄÅÊ£ÄÊµãÔºåÁ¥ØËÆ°‰∏ÄÊÆµÊó∂Èó¥ÂêéÊõ¥Êñ∞Áä∂ÊÄÅ
 136   2      
 137   2              // {
 138   2              //     static volatile u32 cnt = 0;
 139   2      
 140   2              //     if (TEMP_75 == temp_status)
 141   2              //     {
 142   2              //         cnt++;
 143   2              //         if (cnt >= (u32)TMR1_CNT_5_MINUTES)
 144   2              //         {
 145   2      
 146   2              //         }
 147   2              //     }
 148   2              // }
 149   2      
 150   2              { // Áî®‰∫é‰∏äÁîµÂ§ö‰πÖ‰πãÂêéÔºåÈôêÂà∂PWMÊúÄÂ§ßÁöÑÂç†Á©∫ÊØî
 151   3                  static u32 cnt = 0;
 152   3                  if (0 == flag_is_time_to_limit_pwm)
 153   3                  {
 154   4                      /*
 155   4                          Â¶ÇÊûúÊ≤°ÊúâÂà∞Âà∞ÈôêÂà∂Âç†Á©∫ÊØîÁöÑÊó∂Èó¥ÔºàÊ†áÂøó‰Ωç‰∏ç‰∏∫1Ôºâ
 156   4                          ÂàôËøõË°åËÆ°Êó∂
 157   4                      */
 158   4                      cnt++;
 159   4                      if (cnt >= SCHEDULE_TIME_TO_LIMIT_PWM)
 160   4                      {
 161   5                          cnt = 0;
 162   5                          flag_is_time_to_limit_pwm = 1;
 163   5                      }
 164   4                  }
 165   3              }
 166   2          }
 167   1      
 168   1          // ÈÄÄÂá∫‰∏≠Êñ≠ËÆæÁΩÆIPÔºå‰∏çÂèØÂà†Èô§
 169   1          __IRQnIPnPop(TMR0_IRQn);
 170   1      }

C51 COMPILER V9.60.7.0   TIME0                                                             01/24/2026 17:50:51 PAGE 4   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    316    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
