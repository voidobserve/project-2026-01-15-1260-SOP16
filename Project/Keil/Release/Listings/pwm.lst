C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 18:00:36 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\Ob
                    -jects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          // ç”±æ¸©åº¦é™åˆ¶çš„PWMå ç©ºæ¯” ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   5          volatile u16 limited_pwm_duty_due_to_temp = MAX_PWM_DUTY;
   6          // ç”±äºå‘åŠ¨æœºä¸ç¨³å®šï¼Œè€Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è
             -®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   7          volatile u16 limited_pwm_duty_due_to_unstable_engine = MAX_PWM_DUTY;
   8          // ç”±äºé£æ‰‡å¼‚å¸¸ï¼Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„æœ€å¤§å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä
             -¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   9          volatile u16 limited_pwm_duty_due_to_fan_err = MAX_PWM_DUTY;
  10          
  11          volatile bit flag_is_time_to_limit_pwm = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦åˆ°äº†é™åˆ¶å ç©ºæ¯”çš„å®šæ—¶æ—¶é—´ï¼ˆç”
             -±å®šæ—¶å™¨ç½®ä½ï¼Œç½®ä½ä¹‹åä¸æ¸…é›¶ï¼‰
  12          
  13          volatile u16 cur_pwm_channel_0_duty;                          // å½“å‰è®¾ç½®çš„ã€ pwm_channle_0 çš„å ç©
             -ºæ¯”ï¼ˆåªæœ‰é¥æ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  14          volatile u16 expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_0 å
             - ç©ºæ¯”
  15          volatile u16 adjust_pwm_channel_0_duty = MAX_PWM_DUTY;        // pwm_channle_0 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  16          
  17          volatile u16 cur_pwm_channel_1_duty;                          // å½“å‰è®¾ç½®çš„ç¬¬äºŒè·¯PWMçš„å ç©ºæ¯”ï¼
             -ˆåªæœ‰é¥æ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  18          volatile u16 expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_1 å
             - ç©ºæ¯”
  19          volatile u16 adjust_pwm_channel_1_duty = MAX_PWM_DUTY;        // pwm_channle_1 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  20          
  21          void pwm_init(void)
  22          {
  23   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); // æ¸…ç©ºè®¡æ•°å€¼
  24   1      
  25   1          // STMR0_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  26   1          STMR0_PSC = STMR_PRESCALE_VAL(0);                           // é¢„åˆ†é¢‘ï¼ˆå¡«å…¥çš„å€¼èŒƒå›´ï¼š0~254ï
             -¼Œå¯¹åº”1~255åˆ†é¢‘ï¼‰
  27   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  28   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  29   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  30   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  31   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  32   1      
  33   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  34   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  35   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  36   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // ä½¿èƒ½
  37   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  38   1      
  39   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03); // P16 14è„š
  40   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  41   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03); // P14 16è„š
  42   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
  43   1          FOUT_S14 = GPIO_FOUT_AF_FUNC;      // AFåŠŸèƒ½è¾“å‡º
  44   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  45   1      
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 18:00:36 PAGE 2   

  46   1          // P15 15è„š ä½œä¸ºç¬¬2è·¯PWMè¾“å‡º
  47   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1); // æ¸…ç©ºè®¡æ•°å€¼
  48   1          // STMR1_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  49   1          STMR1_PSC = STMR_PRESCALE_VAL(0);                           // é¢„åˆ†é¢‘ï¼ˆå¡«å…¥çš„å€¼èŒƒå›´ï¼š0~254ï
             -¼Œå¯¹åº”1~255åˆ†é¢‘ï¼‰
  50   1          STMR1_PRH = STMR_PRD_VAL_H((STMR1_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  51   1          STMR1_PRL = STMR_PRD_VAL_L((STMR1_PEROID_VAL >> 0) & 0xFF);
  52   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼ (æ¸…ç©ºæ¯”è¾ƒå€¼)
  53   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  54   1          STMR_PWMVALA |= STMR_1_PWMVALA(0x1);              // STMR1 PWMè¾“å‡ºå€¼ ( 0x1:è®¡æ•°CNTå¤§äºç­‰äºæ¯”
             -è¾ƒå€¼A,PWMè¾“å‡º1,å°äºè¾“å‡º0 )
  55   1      
  56   1          STMR_CNTMD |= STMR_1_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  57   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  58   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1); //
  59   1          STMR_CNTEN |= STMR_1_CNT_EN(0x1);   // ä½¿èƒ½
  60   1          STMR_PWMEN |= STMR_1_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  61   1      
  62   1      #if USE_MY_TEST_PIN
                  P0_MD1 &= ~GPIO_P05_MODE_SEL(0x03); // ç”¨å¼€å‘æ¿ä¸Šçš„ p05
                  P0_MD1 |= GPIO_P05_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
              #else
  67   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03); // P15 15è„š
  68   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
  69   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
  70   1      #endif //  #if USE_MY_TEST_PIN
  71   1      }
  72          
  73          // è®¾ç½®é€šé“0çš„å ç©ºæ¯”
  74          void set_pwm_channel_0_duty(u16 channel_duty)
  75          {
  76   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  77   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  78   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  79   1      }
  80          
  81          // è®¾ç½®é€šé“1çš„å ç©ºæ¯”
  82          void set_pwm_channel_1_duty(u16 channel_duty)
  83          {
  84   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  85   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  86   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  87   1      }
  88          
  89          // æ ¹æ®9è„šçš„ç”µå‹æ¥è®¾å®š16è„šçš„ç”µå¹³ï¼ˆè¿‡å‹ä¿æŠ¤ï¼‰
  90          // void according_pin9_to_adjust_pin16(void)
  91          // {
  92          //     // å½“9è„šç”µå‹é«˜äº 3.6 Væ—¶ï¼Œ16è„šè¾“å‡º1KHz é«˜ç”µå¹³,ç”¨äºæ§åˆ¶Q2çš„å¯¼é€šï¼ˆç”¨äºå…³æœºï
             -¼‰ã€‚
  93          //     // if (adc_val_pin_9 >= 3511)
  94          //     // {
  95          //     //     P14 = 1;
  96          //     // }
  97          //     // else if (adc_val_pin_9 <= 3511 - 40)
  98          //     {
  99          //         P14 = 0;
 100          //     }
 101          // }
 102          
 103          /**
 104           * @brief è·å–ç¬¬ä¸€è·¯PWMçš„è¿è¡ŒçŠ¶æ€
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 18:00:36 PAGE 3   

 105           *
 106           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 107           */
 108          u8 get_pwm_channel_0_status(void)
 109          {
 110   1          if (STMR_PWMEN & 0x01) // å¦‚æœpwm0ä½¿èƒ½
 111   1          {
 112   2              return 1;
 113   2          }
 114   1          else // å¦‚æœpwm0æœªä½¿èƒ½
 115   1          {
 116   2              return 0;
 117   2          }
 118   1      }
 119          
 120          /**
 121           * @brief è·å–ç¬¬äºŒè·¯PWMçš„è¿è¡ŒçŠ¶æ€
 122           *
 123           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 124           */
 125          u8 get_pwm_channel_1_status(void)
 126          {
 127   1          if (STMR_PWMEN & (0x01 << 1)) // å¦‚æœpwm1ä½¿èƒ½
 128   1          {
 129   2              return 1;
 130   2          }
 131   1          else // å¦‚æœ pwm æœªä½¿èƒ½
 132   1          {
 133   2              return 0;
 134   2          }
 135   1      }
 136          
 137          void pwm_channel_0_enable(void)
 138          {
 139   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 140   1          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
 141   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 142   1      }
 143          
 144          void pwm_channel_0_disable(void)
 145          {
 146   1          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
 147   1          P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 148   1      
 149   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
 150   1          STMR_PWMEN &= ~0x01; // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
 151   1      }
 152          
 153          void pwm_channel_1_enable(void)
 154          {
 155   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 156   1          STMR_PWMEN |= 0x01 << 1; // ä½¿èƒ½PWM1çš„è¾“å‡º
 157   1      
 158   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
              #else
 161   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
 162   1      #endif
 163   1      }
 164          
 165          void pwm_channel_1_disable(void)
 166          {
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 18:00:36 PAGE 4   

 167   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_AF_FUNC; //;
                  P05 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
              #else
 171   1          FOUT_S15 = GPIO_FOUT_AF_FUNC; //
 172   1          P15 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 173   1      #endif
 174   1      
 175   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
 176   1          STMR_PWMEN &= ~(0x01 << 1); // ä¸ä½¿èƒ½PWM1çš„è¾“å‡º
 177   1      }
 178          
 179          /**
 180           * @brief æ ¹æ®ä¼ å‚ï¼ŒåŠ ä¸Šçº¿æ§è°ƒå…‰çš„é™åˆ¶ã€æ¸©åº¦è¿‡çƒ­é™åˆ¶ã€é£æ‰‡å·¥ä½œå¼‚å¸¸é™åˆ¶ï¼Œ
 181           *          è®¡ç®—æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰pwmé€šé“éƒ½æœ‰æ•ˆï¼‰
 182           *
 183           * @attention å¦‚æœåå¤è°ƒç”¨ adjust_pwm_channel_x_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_chan
             -nel_x_duty);
 184           *              ä¼šå¯¼è‡´ adjust_pwm_channel_x_duty è¶Šæ¥è¶Šå°
 185           *
 186           * @param pwm_adjust_duty ä¼ å…¥çš„ç›®æ ‡å ç©ºæ¯”ï¼ˆéæœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼‰ expect_adjust_pwm_chan
             -nel_x_duty
 187           *
 188           * @return u16 æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 189           */
 190          u16 get_pwm_channel_x_adjust_duty(u16 pwm_adjust_duty)
 191          {
 192   1          // å­˜æ”¾å‡½æ•°çš„è¿”å›å€¼ -- æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 193   1          // æ ¹æ®è®¾å®šçš„ç›®æ ‡å ç©ºæ¯”ï¼Œæ›´æ–°ç»è¿‡æ—‹é’®é™åˆ¶ä¹‹åçš„ç›®æ ‡å ç©ºæ¯”ï¼š
 194   1          u16 tmp_pwm_duty = 0;
 195   1          u16 limited_pwm_duty_due_to_schedule = PWM_DUTY_100_PERCENT; // ç”±å®šæ—¶æ—¶é—´é™åˆ¶çš„PWMå ç©ºæ¯”
 196   1      
 197   1          if (flag_is_time_to_limit_pwm)
 198   1          {
 199   2              /*
 200   2                  ç”±äºæ—‹é’®è°ƒèŠ‚ä¼˜å…ˆçº§æœ€é«˜ï¼Œå®šæ—¶æ—¶é—´é™åˆ¶çš„PWMå ç©ºæ¯”åˆä¸å±äºå¼‚å¸¸ï¼Œ
 201   2                  è¿™é‡ŒæŠŠå¯è°ƒçš„PWMå ç©ºæ¯”ä» 0 ~ limited_max_pwm_duty å¯¹åº”çš„ç™¾åˆ†æ¯” æ˜ å°„æˆ
 202   2                  0 ~ SCHEDULE_TIME_TO_LIMIT_PWM_VAL å¯¹åº”çš„ç™¾åˆ†æ¯”
 203   2              */
 204   2              limited_pwm_duty_due_to_schedule = SCHEDULE_TIME_TO_LIMIT_PWM_VAL;
 205   2          }
 206   1      
 207   1          tmp_pwm_duty = ((u32)pwm_adjust_duty * limited_max_pwm_duty / PWM_DUTY_100_PERCENT) * limited_pwm_duty
             -_due_to_schedule / PWM_DUTY_100_PERCENT; // pwm_adjust_duty * æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ç³»æ•°
 208   1      
 209   1          // æ¸©åº¦ã€å‘åŠ¨æœºå¼‚å¸¸åŠŸç‡ä¸ç¨³å®šã€é£æ‰‡å¼‚å¸¸ï¼Œéƒ½æ˜¯å¼ºåˆ¶é™å®šå ç©ºæ¯”
 210   1          // åˆ¤æ–­ç»è¿‡æ—‹é’®é™åˆ¶ä¹‹åçš„å ç©ºæ¯” ä¼šä¸ä¼š å¤§äº æ¸©åº¦è¿‡çƒ­ä¹‹åé™åˆ¶çš„å ç©ºæ¯”
 211   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_temp)
 212   1          {
 213   2              tmp_pwm_duty = limited_pwm_duty_due_to_temp;
 214   2          }
 215   1      
 216   1          // å¦‚æœé™åˆ¶ä¹‹åçš„å ç©ºæ¯” å¤§äº ç”±äºå‘åŠ¨æœºä¸ç¨³å®šè€Œé™åˆ¶çš„ã€å¯ä»¥è°ƒèŠ‚çš„æœ€å¤§å
             - ç©ºæ¯”
 217   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_unstable_engine)
 218   1          {
 219   2              tmp_pwm_duty = limited_pwm_duty_due_to_unstable_engine;
 220   2          }
 221   1      
 222   1          // å¦‚æœé™åˆ¶ä¹‹åçš„å ç©ºæ¯” å¤§äº ç”±äºé£æ‰‡å¼‚å¸¸ï¼Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„æœ€å¤§å ç©ºæ
             -¯”
 223   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_fan_err)
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 18:00:36 PAGE 5   

 224   1          {
 225   2              tmp_pwm_duty = limited_pwm_duty_due_to_fan_err;
 226   2          }
 227   1      
 228   1          return tmp_pwm_duty; // è¿”å›ç»è¿‡çº¿æ§è°ƒå…‰é™åˆ¶ä¹‹åçš„ã€æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 229   1      }
 230          
 231          // æ›´æ–° pwm_channel_0 å¾…è°ƒæ•´çš„å ç©ºæ¯”
 232          // void update_pwm_channel_0_adjust_duty(void)
 233          // {
 234          //     adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 235          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    410    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     18       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
